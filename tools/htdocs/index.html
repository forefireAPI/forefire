<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ForeFire Super Console</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    /* Global Styles */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: monospace;
      background-color: #111;
      color: #eee;
    }
    /* Container: uses flex to stack sections vertically */
    #container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    /* Header: big orange date */
    #dateHeader {
      background: #111;
      text-align: center;
      font-size: 2em;
      color: orange;
      padding: 10px;
    }
    /* Response Console: shows only the responses from commands */
    #responseConsole {
      background: #222;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
    }
    /* Input Area: contains the command input, send button, and refresh button.
       Height is set to half of responseConsole's height (i.e. 100px) */
    #inputArea {
      display: flex;
      align-items: center;
      height: 40px;
    }
    #inputArea input {
      flex: 1;
      padding: 5px;
      font-size: 1em;
      background-color: #333;
      color: #eee;
      border: 1px solid #444;
    }
    #inputArea button {
      padding: 5px 10px;
      background-color: #444;
      color: #eee;
      border: none;
      cursor: pointer;
    }
    /* Command Buttons: predefined command buttons */
    #commandButtons {
      margin: 5px;
    }
    #commandButtons button {
      padding: 5px 10px;
      margin: 2px;
      background-color: #444;
      color: #eee;
      border: none;
      cursor: pointer;
      font-size: 0.9em;
    }
    #commandButtons button:hover {
      background-color: #555;
    }
    /* Map container */
    #map {
      flex: 1;
      margin: 5px;
    }
    /* Command History: shows the sent commands (in green) */
    #commandHistory {
      background: #222;
      padding: 10px;
      height: 100px;
      overflow-y: auto;
      margin: 5px;
      color: lightgreen;
    }
    /* Sent command styling */
    .commandText {
      margin: 2px 0;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Header: Big, orange date -->
    <div id="dateHeader">Date: N/A</div>

    <!-- Response Console: Only server responses (dark background) -->
    <div id="responseConsole"></div>

    <!-- Command History: Shows the commands that were sent (in green) -->
    <div id="commandHistory"></div>
    <!-- Input Area: Input box, Send button, Refresh Map button -->
    <div id="inputArea">
      <input type="text" id="commandInput" placeholder="Enter command">
      <button id="sendCommand">Send</button>
      <button id="refreshMap">Refresh Map</button>
    </div>

    <!-- Predefined Command Buttons -->
    <div id="commandButtons"></div>

    <!-- Map Container -->
    <div id="map"></div>

  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <!-- togeojson for KML conversion -->
  <script src="https://unpkg.com/togeojson@0.16.0/togeojson.js"></script>
  <script>
    // Updated list of commands.
    const commands = {
      "FireDomain": "FireDomain[sw=(0.0,0.0,0.0);ne=(100.0,100.0,0.0);t=0.0]",
      "FireNode": "FireNode[loc=(0.0,0.0,0.0);vel=(0.0,0.0,0.0);t=0.]",
      "FireFront": "FireFront[]",
      "startFire": "startFire[lonlat=(9.0,42.0,0.0);t=0.0]",
      "step": "step[dt=5]",
      "trigger": "trigger[fuelIndice;loc=(x,y,z);fuelType=int or wind;loc=(x,y,z);vel=(vx,vy,vz);t=f]",
      "goTo": "goTo[t=56.2]",
      "print": "print[]",
      "save": "save[]",
      "load": "load[]",
      "plot": "plot[parameter=speed;filename=out_file_name.png;range=(0,0.1);cmap=viridis]",
      "computeSpeed": "computeSpeed[]",
      "setParameter": "setParameter[param=value]",
      "setParameters": "setParameters[param1=val1;param2=val2]",
      "getParameter": "getParameter[key=]",
      "include": "include[input]",
      "help": "help",
      "loadData": "loadData[data.nc;2024-12-13T15:41:33Z]",
      "clear": "clear[]",
      "systemExec": "systemExec[ls]",
      "quit": "quit[]"
    };

    // Populate predefined command buttons.
    const commandButtonsDiv = document.getElementById('commandButtons');
    for (const cmd in commands) {
      const btn = document.createElement('button');
      btn.textContent = cmd;
      btn.addEventListener('click', () => {
        // Fill the command input (the "ff:" prefix is added automatically).
        document.getElementById('commandInput').value = commands[cmd];
      });
      commandButtonsDiv.appendChild(btn);
    }

    // Initialize Leaflet map.
    const map = L.map('map').setView([42.0, 9.0], 8);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    let mapLayer = null;
    // Update map with KML overlay.
    function updateMapWithKML(kmlText) {
      if (mapLayer) {
        map.removeLayer(mapLayer);
      }
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
      const geojson = toGeoJSON.kml(kmlDoc);
      mapLayer = L.geoJSON(geojson).addTo(map);
      if (mapLayer.getBounds && mapLayer.getBounds().isValid()) {
        map.fitBounds(mapLayer.getBounds());
      }
    }
    // Update map with GeoJSON overlay.
    function updateMapWithGeoJSON(geojson) {
      if (mapLayer) {
        map.removeLayer(mapLayer);
      }
      mapLayer = L.geoJSON(geojson).addTo(map);
      if (mapLayer.getBounds && mapLayer.getBounds().isValid()) {
        map.fitBounds(mapLayer.getBounds());
      }
    }

    // Send command function: auto-prefix with "ff:" if needed.
    async function sendCommand(command) {
            // Append the sent command (in green) to the Command History.
      const responseDiv = document.getElementById('responseConsole');
      const historyDiv = document.getElementById('commandHistory');
      historyDiv.innerHTML += "<div class='commandText'> " + command + "</div>";
      historyDiv.scrollTop = historyDiv.scrollHeight;
      responseDiv.innerHTML += "<div class='commandText'>forefire >" + command + "</div>";
      responseDiv.scrollTop = responseDiv.scrollHeight;

      if (!command.startsWith("ff:")) {
        command = "ff:" + command;
      }


      try {
        const response = await fetch('/', {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain' },
          body: command
        });
        const text = await response.text();
        // Append the response to the Response Console.
        
     
        responseDiv.innerHTML += "<div><pre>" + text + "</pre></div>";
        responseDiv.scrollTop = responseDiv.scrollHeight;

        // If the response looks like KML, update the map.
        const trimmed = text.trim();
        if (trimmed.startsWith("<?xml") || trimmed.startsWith("<kml")) {
          updateMapWithKML(text);
        }
        return text;
      } catch (error) {
        document.getElementById('responseConsole').innerHTML += "<div>Error: " + error + "</div>";
        return null;
      } finally {
        // Update the header date.
        updateISODate();
      }
    }

    // Update ISOdate in the header.
    async function updateISODate() {
      try {
        const response = await fetch('/', {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain' },
          body: "ff:getParameter[ISOdate]"
        });
        const isoText = await response.text();
        document.getElementById('dateHeader').textContent = isoText;
      } catch (error) {
        document.getElementById('dateHeader').textContent = "Error retrieving date";
      }
    }

    // Refresh Map button: set dump mode to geojson then print.
    document.getElementById('refreshMap').addEventListener('click', async () => {
      await sendCommand("setParameter[dumpMode=geojson]");
      const geojsonText = await sendCommand("print[]");
      if (geojsonText) {
        try {
          const geojson = JSON.parse(geojsonText);
          updateMapWithGeoJSON(geojson);
        } catch (e) {
          console.error("Failed to parse GeoJSON:", e);
        }
      }
    });

    // Send command when Send button is clicked.
    document.getElementById('sendCommand').addEventListener('click', () => {
      const command = document.getElementById('commandInput').value.trim();
      if (command !== "") {
        sendCommand(command);
        document.getElementById('commandInput').value = "";
      }
    });

    // Also send command when Enter is pressed.
    document.getElementById('commandInput').addEventListener('keypress', (e) => {
      if (e.key === "Enter") {
        const command = document.getElementById('commandInput').value.trim();
        if (command !== "") {
          sendCommand(command);
          document.getElementById('commandInput').value = "";
        }
      }
    });

    // On double-clicking the map, populate the command input with coordinates.
    map.on('dblclick', function(e) {
      const lat = e.latlng.lat.toFixed(6);
      const lon = e.latlng.lng.toFixed(6);
      document.getElementById('commandInput').value = "lonLng(" + lon + ", " + lat + ",0)";
    });
  </script>
</body>
</html>
